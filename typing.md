# Дотошная типизация с нечестным хаком

## z-index превыше всего

У нас на проекте возникла необходимость декларативно описывать все используемые z-index'ы.
Было решено создать такую архитектуру: будет один массив, который будет содержать информацию про слои отображения.

Например:

```typescript
const LAYERS = [
    ["Фон"],
    ["Текст", "Кнопка"],
    ["BlurEffect"],
    ["Попап"],
    ["Нотификация"].
]
```

(В нашем проекте не используется кирилица, это просто пример)

Таким образом "Фон" будет иметь z-index ниже чем "Текст" или "Кнопка". "BlurEffect" будет иметь z-index выше чем "Текст"(и "Кнопка") и "Фон".

Таким образом если нам неоходимо поместить нотификации ниже попапа - мы просто перемещаем в этом конфиге этот элемент выше(ближе к началу массива).

Также была написана функция `getZIndex` которая принимала на вход имя компонента и возвращала необходимый `z-index`.

```typescript
function getZIndex(componentId) {
  // ...
  // Некоторое вычисление
  // ...
  return zIndex;
}
```

Пример использования:

```typescript
const Background = styled.div`
  z-index: ${getZIndex("Фон")}; // same as z-index: 0
`;
const Notification = styled.div`
  z-index: ${getZIndex("Нотификация")}; // same as z-index: 0
`;
```

Но потом возникла необходимость выделить участок некоторый промежуток `z-index`ов под определённый вид компонентов, поэтому нужно было добавить понятие группы компонентов.

Так что наш конфиг слоёв стал иметь следующий вид:

```typescript
const LAYERS = [
    ["Фон"],
    ["Текст", "Кнопка"],
    ["BlurEffect"],
    [["Попап", 5]],
    ["Нотификация"].
]
```

Это означало что под попапы будет выделено пять `z-index`ов. Так что попап под индексом `0` будет иметь `z-index` меньший чем попап с индексом `1` и так далее. Но попап всегда будет ниже чем нотификации. И всегда выше BlurEffect.

Также создали функцию `getZIndexOfGroupMember` которая по `id` группы и индексу элемента группы отдавал `z-index`.

```typescript
function getZIndexOfGroupMember(groupId, memberIndex) {
  // ...
  // Некоторое вычисление
  // ...
  return zIndex;
}
```

Пример использования:

```typescript
getZIndex("BlurEffect"); // 3
getZIndexOfGroupMember("Попап", 0); // 4
getZIndexOfGroupMember("Попап", 1); // 5
getZIndexOfGroupMember("Попап", 2); // 6
getZIndexOfGroupMember("Попап", 3); // 7
getZIndexOfGroupMember("Попап", 4); // 8
getZIndex("Нотификация"); // 9
```

Таким образом у нас есть промежуток `z-index`ов от 4-го до 8-го выделенный под попапы.

## Типизируйте сударь

Вопрос как типизировать эти две функции. Есть множество способов по степени дотошности в хорошем смысле.

### Бессмыссленный

```typescript
const LAYERS: any = // ...
function getZIndex(componentId: any) { /* ... */ }
function getZIndexOfGroupMember(groupId: any, index: any) { /* ... */ }
```

Не буду долго останавливаться - это тривиальный способ добавить типов, которые не дают никаких гарантий.

## На скорую руку

Можем заметить, что `LAYERS` не просто любое значение, а массив значений строго определённой формы.

```typescript
type Layer = (string | [string, number])[]
const LAYERS: Layer[] = // ...
```

Аналогично можем затипизировать функции:

```typescript
function getZIndex(componentId: string) { /* ... */ }
function getZIndexOfGroupMember(groupId: string, index: number) { /* ... */ }
```

Такого рода типизация даёт некоторые 


